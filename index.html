<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="zhangzhaoaaa,zeromike,javascript,前端,技术" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="这是zeromike的时光机器,技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Zeromike的时光机">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Zeromike的时光机">
<meta property="og:description" content="这是zeromike的时光机器,技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Zeromike的时光机">
<meta name="twitter:description" content="这是zeromike的时光机器,技术博客">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>


  <title> Zeromike的时光机 </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Zeromike的时光机</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mylinks">
          <a href="/mylinks" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-external-link"></i> <br />
            
            链接
          </a>
        </li>
      
        
        <li class="menu-item menu-item-todos">
          <a href="/todos" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-list"></i> <br />
            
            TODO
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/13/将NodeList转化为Node数组/" itemprop="url">
                  将NodeList转化为Node数组
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-01-13T18:40:36+08:00" content="2017-01-13">
              2017-01-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/JS基础/" itemprop="url" rel="index">
                    <span itemprop="name">JS基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/01/13/将NodeList转化为Node数组/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/13/将NodeList转化为Node数组/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在我们的开发过程中，有时候需要遍历同类型的DOM节点然后进行处理，我们知道DOM节点继承于Node，所以其接口方法都是Node的，对于这种类似数组的结构，我们没有办法直接使用Array的方法来处理NodeList，因为它本身不是数组，但是我们有办法将其转化成数组，下面展示NodeList的遍历和转化为数组后的遍历</p>
<h3 id="NodeList"><a href="#NodeList" class="headerlink" title="NodeList"></a>NodeList</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt; </div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;NodeList to Array&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;!-- div NodeList --&gt;</div><div class="line">&lt;div id=&quot;1&quot; data-value=&quot;1&quot;&gt;1&lt;/div&gt;</div><div class="line">&lt;div id=&quot;2&quot; data-value=&quot;2&quot;&gt;2&lt;/div&gt;</div><div class="line">&lt;div id=&quot;3&quot; data-value=&quot;3&quot;&gt;3&lt;/div&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    // 返回 NodeList</div><div class="line">    var div_list = document.querySelectorAll(&apos;div&apos;);</div><div class="line"></div><div class="line">    // 动态创建一个div</div><div class="line">    var div4 = document.createElement(&apos;div&apos;);</div><div class="line">    div4.setAttribute(&apos;id&apos;, 4);</div><div class="line">    div4.setAttribute(&apos;data-value&apos;, 4);</div><div class="line"></div><div class="line"></div><div class="line">    // 1. 将 NodeList 转换为数组</div><div class="line">    var div_array = Array.prototype.slice.call(div_list);</div><div class="line">    // 增加一个Element</div><div class="line">    div_array.push(div4);</div><div class="line">    // 遍历div_array</div><div class="line">    div_array.forEach(function(current)&#123;</div><div class="line">        console.log(&apos;Array.prototype.slice.call: &apos; + current)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    // 2. 将 NodeList 转换为数组</div><div class="line">    var dArray = Array.from(div_list);</div><div class="line">    // 增加一个Element</div><div class="line">    dArray.push(div4);</div><div class="line">    // 遍历dArray</div><div class="line">    dArray.forEach(function(c)&#123;</div><div class="line">        console.log(&apos;Array.from: &apos; + c.getAttribute(&quot;data-value&quot;))</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    // 3. 将 NodeList 转换为数组</div><div class="line">    var array = [...div_list];</div><div class="line">    // 增加一个Element</div><div class="line">    array.push(div4);</div><div class="line">    // 遍历array</div><div class="line">    array.forEach(function(c)&#123;</div><div class="line">        console.log(&apos;[...]: &apos; + c)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    // 4. 对Node本身,可使用for/for..of/forEach遍历</div><div class="line">    for (var i = 0, len = div_list.length; i &lt; len; i++) &#123;</div><div class="line">        console.log(&apos;for: &apos; + div_list[i].getAttribute(&quot;data-value&quot;))</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (var item of div_list) &#123;</div><div class="line">        console.log(&apos;for...of: &apos; + item.id);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //会报错的</div><div class="line"></div><div class="line">    // div_list.push(&apos;&lt;div&gt;4&lt;/div&gt;&apos;);</div><div class="line"></div><div class="line">    div_list.forEach(function(c) &#123;</div><div class="line">        console.log(&apos;forEach: &apos; + c);</div><div class="line">    &#125;)</div><div class="line"></div><div class="line"></div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p><strong>运行结果</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(4次)Array.prototype.slice.call: [object HTMLDivElement]</div><div class="line">Array.from: 1</div><div class="line">Array.from: 2</div><div class="line">Array.from: 3</div><div class="line">Array.from: 4</div><div class="line">(4次)[...]: [object HTMLDivElement]</div><div class="line">for: 1</div><div class="line">for: 2</div><div class="line">for: 3</div><div class="line">for...of: 1</div><div class="line">for...of: 2</div><div class="line">for...of: 3</div><div class="line">(3次)forEach: [object HTMLDivElement]</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/13/位移运算/" itemprop="url">
                  位移运算
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-01-13T10:05:58+08:00" content="2017-01-13">
              2017-01-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/01/13/位移运算/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/13/位移运算/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/11/算法设计基础/" itemprop="url">
                  算法设计基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-01-11T14:05:19+08:00" content="2017-01-11">
              2017-01-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/算法设计/" itemprop="url" rel="index">
                    <span itemprop="name">算法设计</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/01/11/算法设计基础/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/11/算法设计基础/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="算法设计的基础"><a href="#算法设计的基础" class="headerlink" title="算法设计的基础"></a>算法设计的基础</h1><p>   编写程序开发软件是冒险者的游戏，需要胆大心细，设计一个解决实际问题的算法尤其如此。显示问题复杂多样，对应的算法也是复杂多样，形态各异，但是这些算法都遵循一些特定的方法和模式。就算法模式而言，处理各种求最优解问题时，人们常用贪婪法、动态规划法等算法模式；处理迷宫类问题时，穷尽式的枚举和回溯是常用的模式。就算法的实现方法而言，如果算法需要频繁地查表操作，那么数据结构的设计通常会选择有序表来实现；反过来，当设计的算法用到了树和图这样的数据结构时，含有递归结构的方法就常常伴随它们左右。</p>
<p>   算法设计是个复杂的内容，单就这个话题就可以写一本书了。</p>
<h2 id="程序的基本结构"><a href="#程序的基本结构" class="headerlink" title="程序的基本结构"></a>程序的基本结构</h2><p>   从大的方面来考量算法问题，相对于并行算法，本书介绍的都是串行算法的设计方法。按照冯 诺依曼计算机体系的设计，计算机的CPU每次只能串行执行一条指令，即使那些号称支持多线程的操作系统，其实际效果也是“宏观上并行、微观上串行”。顺序执行、循环和分支跳转是程序设计的三大基本结构，算法也是程序，千姿百态的算法也是由这三大基础结构构成的。</p>
<h3 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h3><p>   顺序执行是算法的基础结构，循环结构的每个循环体内也是顺序执行的，分支和跳转的每个分支内也是顺序执行的。假如算法中某个操作需要几个步骤完成，每个步骤都依赖于前一个步骤，将前一个步骤的输出作为下一个步骤的输入，中间不能打断和调整顺序，这样的结构就是算法的顺序执行结构</p>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>   循环结构也是算法中一种很重要的控制流程，循环被定义为在算法中只出现一次但是却有可能被执行多次的一段逻辑体。从实际应用角度看，稍微复杂一点的算法都会用到循环结构。循环结构一般由三部分组成：循环初始化、循环体和循环条件（退出条件）。</p>
<h3 id="分支和跳转结构"><a href="#分支和跳转结构" class="headerlink" title="分支和跳转结构"></a>分支和跳转结构</h3><p>   顺序结构可以解决计算、输入和输出等问题，但是不能作判断和选择。分支和跳转结构在程序中扮演着重要的角色，正是由于有了分支和跳转，程序才能产生多种多样的结果。</p>
<h2 id="算法实现与数据结构"><a href="#算法实现与数据结构" class="headerlink" title="算法实现与数据结构"></a>算法实现与数据结构</h2><p>   计算机体系中的数据，是指能被计算机识别和处理的各种符号的总称。人类所能识别的各种数据，比如文字、语言和图像，在计算机内都是以二进制形式存在的，但是这些二进制数据之间存在着各种组织关系。我们通常说的数据结构，其实包含了两层意思，一是指相互之间存在某种特定关系的数据的集合，二是指数据之间的相互关系，也就是数据的逻辑结构。因此，当我们说定义数据结构时，除了定义数据之间的相互关系，还包括根据这些关系组织在一起的数据。在建立数据模型的阶段，我们说的数据结构更偏重于定义数据之间的相互关系，设计具体的算法步骤时，考虑的是如何对构建在这些数据关系之上的实际数据进行加工和处理。</p>
<h3 id="基本数据结构在算法设计中的应用"><a href="#基本数据结构在算法设计中的应用" class="headerlink" title="基本数据结构在算法设计中的应用"></a>基本数据结构在算法设计中的应用</h3><p>线性表是数据结构中最简单的基本数据结构。线性表的使用和维护都很简单。数组、链表、栈和队列是四种最常见的线性表，其外部行为和接口都各有特色。</p>
<p>1.数组</p>
<p>   数组是一种相对比较简单的数据组织关系，所有数据元素存储在一片连续的区域内。对数组的访问方式一般是通过下标直接访问数组元素，除此之外，对数组的基本操作还有插入、删除和查找。数组元素的直接访问几乎没有开销，但是插入和删除操作需要移动数组元素，开销比较大，因此在插入和删除操作比较频繁的场合下，不适合数组。在数组中查找一个元素的时间复杂度是O(n)，如果数组元素是有序存储的，则使用二分查找可以将时间复杂度将为O(lgn).</p>
<p>   在数组中存储的数组元素，除了数组元素的值需要关注之外，数组元素的下标也是一个很有用的属性，有时候可以巧妙地利用下标简化一些算法的实现方式。例如，有若干个数存放在value数组中，这些数的取值范围是[1-100]，请设计一个算法统计一下这些数中相同的数出现的次数。经分析发现，虽然value中数字的个数很多，但是范围并不大，可以设计一个有100个元素的数组，数组元素的下标对应数字，数组元素的值就是对应数字出现的次数，只需如下两行代码即可完成统计工作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (int i = 0; i &lt; count; i++ )&#123;</div><div class="line">numCount[values[i] - 1]++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>   虽然对于那些没有出现过得数字也需要占用numCountp[]数组的一个位置，但是这点空间上的开销是可以接受的。</p>
<p>2.链表</p>
<p>   在线性表的长度不能确定的场合，一般会采用链表的形式。链表结构的每个节点数据都由两个域组成，一个是存放实际数据元素的数据域，另一个是构成链式结构的指针域。对于单向链表，指针域只有一个后向指针，对于双向链表，指针域由一个后向指针和一个前向指针组成。链表的插入和删除只需要修改指针域的指针指向即可完成，比数组的插入和删除操作效率高，但是访问数据元素的效率比较低，需要从链表头部向后（向前）搜索，查找操作的时间复杂度是O(n)。理论上链表的长度是不受限制的，实际使用链表时，常受存储器空间的限制，使得链表长度也不能无限增长，但是链表长度可动态变化这一点，比数组具有很大的优势。</p>
<p>   单向链表只能在一个方向上遍历链表节点，从一个节点开始遍历到链表的尾部节点就停止。双向链表可以从两个方向遍历链表节点，从一个节点开始，向前遍历到链表头部节点停止，向后遍历到链表尾部节点停止。在某些应用场合，还可以将链表尾部节点的后向指针指向链表头部节点（对于双向链表，其头部节点的前向指针同时指向链表的尾部节点），构成一个环形链表。环形链表中头部节点和尾部节点的概念已经弱化，从任何一个节点开始都可以遍历整个链表。</p>
<p>   链表的头节点作为整个链表遍历的起点，是一个比较特殊的节点，需要特殊处理，尤其是在插入和删除节点的时候。如果节点插入在头节点之前，或者删除的节点就是头节点，就需要调整链表头节点的指针，否则的话，仍用原来保存的头节点访问链表，就可能跳过新插入的节点，或者操作已经失效的指针。为了解决这个问题，人们设计了一种在链表中使用固定头节点的方法，这个固定的头节点称为“表头节点”。也被称为“哑节点”。表头节点可以是一个没有数据域、只有指针域的特殊节点，也可以是和其他节点类型一样的节点（数据域不使用），更多的情况是在表头节点的数据域中放置一些与链表有关的状态信息，比如当前链表中的数据元素节点个数。表头节点的指针域始终指向第一个实际链表节点，如果表头节点的指针域是NULL，则表示这个链表是空表。使用表头结点的好处有两个，一个好处是无论链表是否为空表，可以用一致的方法处理空链表和非空链表；另一个好处是对链表进行插入、删除和遍历操作时，不需要对数据元素的首节点和中间节点做差异处理，对每个节点的操作可以做到一致性。</p>
<p>   除了查找和访问的效率没有数组高之外，链表的每个节点都要额外存储一个指针域，因此需要一定的存储开销。对于一些插入和删除操作比较少，查找、遍历操作比较多的场合，应该优先选择使用可变长数组代替链表。</p>
<p>3.栈</p>
<p>   栈是一种特殊的线性表，其特殊性在于只能在表的一端插入和删除数组元素，插入和删除动作分别称为“入栈”和“出栈”。严格来说，栈不是一种数据存储方式，二是一种逻辑管理方式，它遵循“后进先出”的原则管理和维护表中的数据。栈的数据存储方式可以采用数组。栈的数据存储方式可以采用数组，也可以使用链表，分别被称为“顺序栈”和“链式栈”，但是无论采用何种存储方式，其外部行为都是一样的，即只能通过“出栈”和“入栈”的方式在数据表的一端操作数据。</p>
<p>   栈是一种非常有用的数据结构，利用栈的一些特性，可以将某算法的递归实现转成非递归实现，在使用穷尽搜索方法时，也会使用栈保存当前的状态，有时候，广度优先搜索和深度优先搜索的差异仅仅是使用栈还是使用队列。</p>
<p>4.队列</p>
<p>   队列也是一种特殊的线性表，普通的队列只能在表的一端插入数据，在另一端删除数据，不能再队列的其他位置插入和删除数据。插入和删除动作分别被称为“入队”和“出队”，能执行“入队”的一端称为“后端”(rear)，能执行出队的一端称为“前端”（front）。与栈一样，队列也不是一种数据存储方式，二是一种逻辑管理方式，它遵循“先进先出”的原则管理和维护表中的数据。队列的数据存储方式可以采用数组，也可以使用链表。</p>
<p>   队列有多种使用形式，比如环形队列（循环队列），还有可以在队列的两端都执行“入队”和“出队”操作的双端队列，还有给每个数据元素打上优先级标签的优先级队列等。<br>   队列在算法中的应用非常广泛，比如图的广度优先搜索算法，就使用一个队列存放与当前搜索节点有相连的所有邻接点，以先进先出的原则一个一个地处理队列中的节点。操作系统中的线程调度算法，常使用带优先级的队列管理就绪线程列表，高优先级的线程插入在队列的前端，获得优先调度（出队）的机会。队列也是不同速率的IO设备之间缓冲区管理的常用方式，比如打印机打印速度比较慢，操作系统会为每个打印机维护一个打印队列，对不同进程提交的打印操作做入队管理，可以避免因一个大文件打印时间过程造成其他进程无法提交打印操作的问题。网络设备中也普遍使用队列来管理数据报文的发送和接收，以匹配不同速率的设备之间的数据传输。</p>
<h3 id="复杂数据结构在算法设计中的应用"><a href="#复杂数据结构在算法设计中的应用" class="headerlink" title="复杂数据结构在算法设计中的应用"></a>复杂数据结构在算法设计中的应用</h3><p>   上一节讨论的基本数据结构都属于线性表范围，表中的数据元素之间没有关系，只是通过不同的组织和管理方式将每个数据元素维护在一个线性表中。本节将介绍的这些数据结构不是简单的线性表，并且每个数据元素之间也可能存在关系，比如树的节点之间存在父子关系，图的节点之间存在邻接关系，等。之所以被称为“复杂数据结构”，是因为相关的插入、删除操作不仅对数据元素进行操作，还要同事维护数据元素之间的关系。</p>
<p>1.树</p>
<p>   树是一种表达数据之间层次关系的数据结构，树中的每个节点有0个或者多个子节点，但是只有一个父节点，一棵树只有一个根节点。树结构的相对概念如下。</p>
<p>   树的度： 一个节点含有子树的个数称为该节点的度，一棵树中最大节点的度称为整棵树的度。</p>
<p>   叶节点： 度为0的节点称为叶节点。</p>
<p>   根节点： 没有父节点的节点就是根节点。</p>
<p>   树的高度： 从根节点开始，每多一级子节点，树的层次就+1，一棵树的最大层次数就是树的高度。</p>
<p>   兄弟节点： 具有相同父节点的子节点互相称为兄弟节点。</p>
<p>   树适合用来表达有层次关系的数据，比如一个公司的分支结构、计算机上的目录和文件结构，等等。如果树的子节点之间有大小关系，则这样的树就称为有序树。树通常也被认为是图的一种形式，是一种没有环路的图，比如自由树可被视为一个连通的、无环路的无向图。根据每个节点的子节点的数量，又可以将树分为二叉树和多叉树，B树就是一种典型的多叉树。</p>
<p>   有序的二叉树也被称为二叉查找树(binary search tree)或者二叉排序树(binary sort tree)。相对于普通的二叉树，二叉查找树有以下两个特点：<br>   如果左子树不为空，则左子树上所有节点的值都小于根节点的值<br>   如果右子树不为空，则右子树上所有节点的值</p>
<p>   二叉查找树的特点是所有新插入的节点都是叶子节点，已经存在的节点的位置比较固定。二叉查找树查找操作的时间复杂度是O(lgn)，虽然线性有序表的查找操作时间复杂度也是O(lgn)（折半查找），但是线性有序表不能表达数据元素之间的关系。简单二叉查找树的插入操作都发生在叶节点，如果构造二叉查找树时依次插入的节点已经是有序的，则二叉树会退化为链表形状的单支树，在这种情况下，查找效率就会下降，查找操作的时间复杂度变成O(n)。为了优化查找效率，就需要二叉查找树能够具有自平衡功能，保证二叉树始终是一棵平衡树。AVL树和红黑树就是这样的自平衡二叉查找树，二者的区别在于维持树的自平衡的方法不一样。在算法设计时，只要有条件就应该优先使用AVL树和红黑树，避免简单二叉查找树可能存在的性能问题。</p>
<p>   二叉查找树在算法中的应用也很广泛，比如决策问题可以使用二叉查找树构造决策树，一些统计问题也可以使用二叉查找树的形式组织各种信息数据节点，其他的问题如果能将最终的结果转化成取舍问题，也可以使用二叉查找树。</p>
<p>   多叉树的典型例子就是B树和各种B树的变形树，B树是一种自平衡多叉查找树，对于一棵M阶B树来说，其每个非终端节点至少有[M/2]个子树，但是最多有M个子树，根节点如果不是终端节点，则至少有2个子树。每个节点有N个关键字，所有的终端节点都在统一的层次上，但是不带任何关键字信息。B+树是B树的一种变性，它与B树的差别在于对终端节点的处理，B+树的所有终端节点包含了全部关键字信息，同时还有指向这些关键字所在节点的指针，并且终端节点按照关键字的大小排序，形成一个有序链接，因此对B+树进行查找，可以从最小关键字开始顺序查找（遍历所有的终端节点），也可以从根节点开始遍历。B树常用于文件管理系统和数据库系统，在算法设计师，如果遇到多路分支且有序的层次结构时，就可以考虑使用B树。</p>
<p>   区间树是一种以区间为数据元素的红黑树，区间树的每个节点都表示一个区间，其关键字是区间的左端点，区间树支持所有的二叉查找树的基本操作，而且区间元素的插入和查找操作都可以在O（lgn）的时间内完成。区间树的查找不是精确查找，但是可以确定区间树上是否存在能完整覆盖给定的被查找区间的节点（区间）。区间树还支持获取某个子树的最大右端点的值的操作，这个操作的意义在于当查找一个区间时，如果左子树的最大右端点的值小于当前查找区间的左端点的值，就说明左子树与当前查找的区间不存在重叠，需要转到右子树继续查找。区间树常用语区间查询相关的问题，比如判断区间之间是否存在重叠区域的呢过问题。</p>
<p>   线段树也是一种 以区间为数据元素的二叉查找树，和区间树不同的是，线段树上的每个非叶子节点表示的区间范围是其子节点的区间范围之和。如果线段树中一个非叶子节点表示的区间是[a,b],则它的左子树表示的区间就是[a,(a+b)/2],右子树表示的区间就是[(a+b)/2,b]，由此可知，线段树是一棵平衡二叉树，一棵表示长度范围为[1,L]的线段树的高度是lg(L)+1。叶子节点表示不可再分的最小区间范围，如果将一个大区间分成n个小区间，则对应的线段树将有n个叶子节点，n个叶子节点的小区间共同组成整个大区间。和区间树一样，线段树也可以用来做区间重叠性判断，除此之外，线段树在统计学相关的问题中应用也很广泛。比如一些统计信息，既需要查询在一个大的区间上的统计值，也需要查询在这个大范围中的某个小范围的统计值，就可以应用线段树。举个例子，假如某杂志需要统计各个年龄段读者的比例，可以将统计的读者数量信息按照年龄区间组织成一颗线段树，如果一个节点左边子节点是年龄在20-30岁之间的读者数量，右边子节点是年龄在30-40之间的读者数量，则这个节点表示的就是年龄在20-40岁之间啊的读者数量。</p>
<p>   堆也是一种完全树，除了树的特征之外，堆的父节点和子节点还存在一些特殊关系。最大堆的每个节点的值都大于其子树上所有节点的值，最小堆的每个节点的值都小于其子树上所有节点的值。堆的插入和删除操作除了维持堆的完全树特征之外，还要维持节点之间的这个特殊关系，通常可以利用这一点实现一些特殊的功能，比如堆排序，就是利用堆的这个特殊性质，再比如经典的“求n个数中最大（或最小）的m个数的问题”，就是通过维护一个有m个节点的最大堆（或最小堆）来实现的。</p>
<p>   解决一些与字符串相关的问题时，还会用到字典树，比如典型的前缀树和后缀树。字典树以树的形式保存大量字符串（前缀或后缀），常被各种文本搜索算法用于文字和词频的统计。字典树的优点是利用字符串的公共前缀或后缀节约存储空间，查找过程中能减少无谓的完整字符串匹配，便于字符串的统计和查找。</p>
<p>2.集合</p>
<p>   简单来说，集合（set）是具有某种特性的事务的整体，构成集合的事物或对象称作集合的元素或成员。<br>      无序性： 一个集合中每个元素的地位都是相同的，元素之间不存在有序关系，也没有类似树和图那样的复杂关系。<br>      互异性： 一个集合中每个元素只能出现一次，也就是说，集合内没有重复的元素。<br>      确定性： 集合的定义是确定的，根据这个定义可以明确判断一个对象是否属于这个集合，不存在模棱两可的情况。</p>
<p>   集合的主要操作包括两部分，一部分是对集合元素的操作，包括插入和删除集合元素、判断一个元素是否属于集合等；另一部分是集合之间的关系运算，包括集合的求交集、并集运算以及求差运算等。</p>
<p>3.哈希表与映射</p>
<p>   哈希表与映射都是通过关键字(key)直接访问数据元素的值（value）的数据结构，二者的外部接口是一样的，但是不同的平台上对内部实现稍有差异。</p>
<p>   哈希表的原理是通过一个哈希函数对关键字进行某种运算，得到对应的数据元素在表中的存储位置，然后访问其值，与普通的有序表查找相比，额外的哈希处理会造成数据访问的开销，但是哈希表的查找时间是固定的，不随哈希表中数据元素的增多而变化。普通有序表的查找时间复杂度是O（lg(n)），随着n的增大，查时间也变长，当数据元素非常多的时候，哈希表的查找速度会比普通有序表快，这就是哈希表的优势。</p>
<p>   现实生活中有很多采用“key-value”方式组织和存储数据的情况，学生成绩管理系统会通过一个唯一分配的学号建立与具体学生信息的映射关系，可以通过学号查询和管理学生信息，这个学号就是key.</p>
<p>4.图</p>
<p>   图是一种特殊的数据组织方式，它不仅可以存储数据元素（对象），还可以存储数据元素之间的复杂关系。从直观上看，图由一些顶点和连接这些顶点的边组成，顶点描述数据元素，边描述数据元素之间的关系。图由很多种分类方式，根据边是否有方向，可将图分为有向图和无向图；根据任意两个顶点之间的边的个数，可将图分为简单图和多重图；根据任意两个顶点之间的连通性，可将图分为连通图和非连通图。根据边的地位平等性，用何种方法对图分类，定义图的方式基本上只有两种：二元组定义和三元组定义。对于图G，如果V(G)表示顶点集，E(G)表示边集，则（V,E）即为图的二元组定义。如果存在关联函数I将E(G)中的每一条边映射到V(G)中的两个顶点，即I(e)=(u,v),其中u,v属于V(G)，且是e的两个顶点，则将（V,E,I）称为图的三元组定义。</p>
<p>   图的存储常用邻接矩阵（二维数组方式）和邻接表（链表或可变长数组）方式，对于有向图，有时候也采用十字链表方式。图的遍历是一个非常重要的操作，一般可采用深度优先搜索和广度优先搜索两种策略。深度优先搜索策略可以理解为树的中序遍历的推广，深度优先搜索的过程是：从图G的某个顶点v出发，先访问v，然后选择一个与v相邻且没有被访问过的顶点vi访问，再从vi出发选择一个与vi相邻且未被访问的顶点vj进行访问，依次遍历。如果当前被访问过的顶点的所有邻接顶点都已被访问，则退回到已被访问的顶点的相邻顶点的顶点vk，从vk出发按同样的方法向前遍历，直到图中的所有顶点都被访问过。</p>
<p>   广度优先搜索的过程是：首先访问初始点v，接着依次访问v的所有未被访问过的邻接点v1,v2,v3….,vi,然后再按照v1,v2,….vi的次序，依次访问这些节点的邻接点（未被访问过的邻接点），依次遍历，直到图中所有和初始点vi相邻的顶点都被访问过为止。为了保证v的所有邻接点被按照顺序依次处理，就需要使用队列来管理这些邻接点。</p>
<p>   显示生活中很多地方都用到了使用图的算法，比如你在地图软件中选择两个点，软件会给出连接这两个点之间的最佳路线，这就要用到图的连通性判断和最短路径搜索算法。当有多条路径可以连接两个点的时候，软件还可以根据不同道路的实时交通拥堵情况，选择最快捷的道路，其实也就是为每条道路设置不同的权重，然后进行带权图的最优路径搜索。交通规划常常需要用最小的成本将不同城市连接起来，保证每个城市之间都可以到达，就需要最小生成树算法。网络设备之间为了避免出现环路，也需要运行一个最小生成树协议，也是图的应用。</p>
<h2 id="数据结构和数学模型与算法的关系"><a href="#数据结构和数学模型与算法的关系" class="headerlink" title="数据结构和数学模型与算法的关系"></a>数据结构和数学模型与算法的关系</h2><p>   建立问题的数学模型实际上是对问题的一种抽象的表达，通常也需要伴随着一些合理的假设，其目的就是对问题进行简化，抓住主要因素，舍弃次要因素，逐步用更精确的语言描述问题，最终过度到用计算机语言能够描述问题为止。让我们来看两个例子。</p>
<p>   一个工程项目经过层层结构分解最终得到一系列具体的活动，这些活动之间往往存在复杂的依赖关系，如何安排这些活动的开始顺序，使得项目能够顺利完成是个艰巨的任务。但是如果能把这个问题转化成有向图，图的顶点就是活动，顶点之间的有向边代表活动之间的前后关系，则只需要使用简单的有向图拓扑排序算法就可以解决这个问题。一个工程分解出这么多的活动，每个活动的时间都不一样，如何确定工程的最短完工时间？工程的最短完工时间取决于这些活动中时间最长到额那条关键活动路径，从成百上千个活动中找出关键路径看似是个无法入手的问题，但是如果将问题转化为有向图，顶点代表事件，边代表活动，边的权代表活动时间，则可以利用有向图的关键路径算法解决问题。</p>
<p>   用三个容器分别为3升、8升和5升的水桶如何获得4升水的问题，是一个经典的智力游戏。如果让计算机像人一样思考并解决这个问题有点困难，但是如果转换思维，将三个水桶中当前的水量定义为一个状态，将倒水定义为一个驱动状态转换的动作，则这个问题就转换为水桶状态的穷举搜索问题。在解空间中用穷举的方法遍历所有可能的解，并找到最终合法的解释解决最优解问题的常用数学模型，只要想到了这个数学模型，这个问题就迎刃而解了。</p>
<p>文章来源：《算法的乐趣》一书</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/08/HTTP缓存/" itemprop="url">
                  HTTP缓存
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-01-08T22:15:14+08:00" content="2017-01-08">
              2017-01-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/性能优化/" itemprop="url" rel="index">
                    <span itemprop="name">性能优化</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/01/08/HTTP缓存/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/08/HTTP缓存/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Web缓存是可以自动保存常见文档副本的HTTP设备。当Web请求抵达缓存时，如果本地有“已缓存的”副本，就可以从本地存储设备而不是原始服务器中提取这个文档。使用缓存有下列优点。</p>
<ul>
<li>缓存减少了冗余的数据传输，节省了你的网络费用。</li>
<li>缓存缓解了网络瓶颈的问题，不需要更多的带宽就能够更快地加载页面。</li>
<li>缓存降低了对原始服务器的要求，服务器可以更快地响应，避免过载的出现。</li>
<li>缓存降低了距离时延，因为从较远的地方加载页面会更慢一些。</li>
</ul>
<h2 id="命中和未命中的"><a href="#命中和未命中的" class="headerlink" title="命中和未命中的"></a>命中和未命中的</h2><h3 id="再验证"><a href="#再验证" class="headerlink" title="再验证"></a>再验证</h3><p>原始服务器的内容可能会发生变化，缓存要不时对其进行检测，看看它们保存的副本是否仍是服务器上最新的副本。这些“新鲜度检测”被称为HTTP再验证（revalidation）。为了有效地进行再验证，HTTP定义了一些特殊的请求，不用从服务器获取整个对象，就可以快速检测出内容是否是最新的。</p>
<p>缓存可以在任意时刻，以任意的频率对副本进行再验证。但由于缓存中通常会包含数百万的文档，而且网络带宽是很珍贵的，所以大部分缓存只有在客户端发起请求，并且副本旧得足以需要检测的时候，才会对副本进行再验证。</p>
<p>缓存对缓存的副本进行再验证时，会向原始服务器发送一个小的再验证请求。如果内容没有变化，服务器会以一个小的304 Not Modified进行响应。只要缓存知道副本仍然有效，就会再次将副本标识为暂时新鲜的，并将副本提供给客户端。这被称为再验证命中(revalidate hit)或缓慢命中(slow hit)。这种方式确实要与原始服务器进行核对，所以会比单纯的缓存命中要慢，但它没有从服务器中获取对象数据，所以要比缓存未命中快一些。</p>
<p>HTTP为我们提供了几个用来对已缓存对象进行再验证的工具，但最常用的是If-Modified-Since首部。将这个首部添加到GET请求中去，就可以告诉服务器，只有在缓存了对象的副本之后，又对其进行了修改的情况下，才发送此对象。</p>
<p>这里列出了在3种情况下（服务器内容未被修改，服务器内容已被修改，或者服务器上的对象被删除了）服务器收到GET If-Modified-Since请求时会发生的情况：</p>
<ul>
<li>再验证命中</li>
</ul>
<p>如果服务器对象未被修改，服务器会向客户端发送一个小的HTTP 304 Not Modified响应。</p>
<ul>
<li>再验证未命中</li>
</ul>
<p>如果服务器对象与已缓存副本不同，服务器向客户端发送一条普通的、带有完整内容的HTTP 200 OK响应</p>
<ul>
<li>对象被删除</li>
</ul>
<p>如果服务器对象已经被删除了，服务器就回送一个 404 Not Found响应，缓存也会将其副本删除。</p>
<p>每个私有缓存都要获取同一份文档，这样它就会多次穿过网络<br>使用共享的公有缓存时，对于这个流行的对象，缓存只要取一次就行了，它会用共享的副本为所有的请求服务</p>
<h3 id="缓存的处理步骤"><a href="#缓存的处理步骤" class="headerlink" title="缓存的处理步骤"></a>缓存的处理步骤</h3><ol>
<li>接收——缓存从网络中读取抵达的请求报文</li>
<li>解析——缓存对报文进行解析，提取出URL和各种首部</li>
<li>查询——缓存查看是否有本地副本可用，如果没有，就获取一份副本（并将其保存在本地）</li>
<li>新鲜度检测——缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新</li>
<li>创建响应——缓存会用新的首部和已缓存的主题来构建一条响应报文</li>
<li>发送——缓存通过网络将响应发回给客户端</li>
<li>日志——缓存可选地创建一个日志文件条目来描述这个事务</li>
</ol>
<h2 id="保持副本的新鲜"><a href="#保持副本的新鲜" class="headerlink" title="保持副本的新鲜"></a>保持副本的新鲜</h2><p>可能不是所有的已缓存副本都与服务器上的文档一致。毕竟，这些文档会随着时间发生变化。报告可能每个月都会变化。在线报纸每天都会发生变化。财经数据可能每过几秒钟就会发生变化。如果缓存提供的总是老的数据，就会变得毫无用处。已缓存数据要与服务器数据保持一致。</p>
<p>HTTP有一些简单的机制可以在不要求服务器记住有哪些缓存拥有其文档副本的情况下，保持已缓存数据与服务器数据之间充分一致。HTTP将这些简单的机制称为文档过期和服务器再验证。</p>
<h3 id="文档过期"><a href="#文档过期" class="headerlink" title="文档过期"></a>文档过期</h3><p>通过特殊的HTTP Cache-Control首部和Expires首部，HTTP让原始服务器向每个文档附加了一个“过期日期”。<br>在缓存文档过期之前，缓存可以以任意频率使用这些副本，而无需与服务器联系——当然，除非客户端请求中包含有阻止提供已缓存或未验证资源的首部。但一旦已缓存文档过期，缓存就必须与服务器进行核对，询问文档是否被修改过，如果被修改过，就要获取一份新鲜（带有新的过期日期）的副本。</p>
<h3 id="过期日期和使用期"><a href="#过期日期和使用期" class="headerlink" title="过期日期和使用期"></a>过期日期和使用期</h3><p>服务器用Expires的首部或者Cache-Control:max-age响应首部来指定过期日期，同时还会带有响应主题。Expires首部和Cache-Control:max-age首部所做的事情本质上是一样的，但由于Cache-Control首部使用的是相对时间而不是绝对日期，所以我们更倾向于使用比较新的Cache-Control首部。绝对日期依赖于计算机时钟的正确设置。</p>
<h3 id="服务器再验证"><a href="#服务器再验证" class="headerlink" title="服务器再验证"></a>服务器再验证</h3><p>仅仅是已缓存文档过期了并不意味着它和原始服务器上目前处于活跃状态的文档有实际的区别，这只是意味着到了要进行核对的时间了。这种情况被称为“服务器再验证”，说明缓存需要询问原始服务器文档是否发生了变化。<br>如果再验证显示内容发生了变化，缓存会获取一份新的文档副本，并将其存储在旧文档的位置上，然后将文档发送给客户端。<br>如果再验证显示内容没有发生变化，缓存只需要获取新的首部，包括一个新的过期日期，并对缓存中的首部进行更新就行了。</p>
<p>缓存并不一定要为每条请求验证文档的有效性——只有在文档过期时它才需要与服务器进行再验证。这样不会提供陈旧的内容，还可以节省服务器的流量，并拥有更好的用户响应时间。</p>
<p>HTTP协议要求行为正确的缓存返回下列内容之一：<br>“足够新鲜”的已缓存副本<br>与服务器进行再验证，确认其仍然新鲜的已缓存副本<br>如果需要与之进行再验证的原始服务器出故障了，就返回一条错误报文<br>附有警告新鲜说明内容可能不正确的已缓存副本</p>
<h3 id="用条件方法进行再验证"><a href="#用条件方法进行再验证" class="headerlink" title="用条件方法进行再验证"></a>用条件方法进行再验证</h3><p>HTTP的条件方法可以高效地实现再验证。HTTP允许缓存向原始服务器发送一个“条件GET”，请求服务器只有在文档与缓存中现有的副本不同时，才回送对象主体。通过这种方式，将新鲜度检测和对象获取结合成了单个条件GET。向GET请求报文中添加一些特殊的条件首部，就可以发起条件GET。只有条件为真时，Web服务器才会返回对象。</p>
<p>HTTP定义了5个条件请求首部。对缓存再验证来说最有用的2个首部是If-Modified-Since和If-None-Match.所有的条件首部都以前缀“If-”开头。</p>
<p>If-Modified-Since:<date> 如果指定日期之后文档被修改过了，就执行请求的方法。可以与Last-Modified服务器响应首部配合使用，只有在内容被修改后与已缓存版本有所不同的时候采取获取内容。</date></p>
<p>If-None-Match:<tags> 服务器可以为文档提供特殊的标签（参见ETag），而不是将其与最近修改日期相匹配，这些标签就像序列号一样。如果已缓存标签与服务器文档中的标签有所不同，If-None-Match首部就会执行所请求的方法。</tags></p>
<h3 id="If-Modified-Since-Date再验证"><a href="#If-Modified-Since-Date再验证" class="headerlink" title="If-Modified-Since:Date再验证"></a>If-Modified-Since:Date再验证</h3><p>最常见的缓存再验证首部是If-Modified-Since。If-Modified-Since再验证请求通常被称为IMS请求。只有自某个日期之后资源发生了变化的时候，IMS请求才会指示服务器执行请求：如果自指定日期后，文档被修改了，If-Modified-Since条件就为真，通常GET就会成功执行。携带新首部的新文档会被返回给缓存，新首部除了其他信息之外，还包含了一个新的过期日期。如果自指定日期后，文档没被修改过，条件为假，会向客户端返回一个小的304 Not Modified响应报文，为了提高有效性，不会返回文档的主体。这些首部是放在响应中返回的，但只会返回那些需要在源端更新的首部。比如，Content-Type首部通常不会被修改，所以通常不需要发送。一般会发送一个新的过期日期。</p>
<p>If-Modified-Since首部可以与Last-Modified服务器响应首部配合工作。原始服务器会将最后的修改日期附加到所提供的文档上去。当缓存要对已缓存文档进行再验证时，就会包含一个If-Modified-Since首部，其中携带有最后修改已缓存副本的日期：If-Modified-Since:<cached last-modified="" date=""><br>如果在此期间内容被修改了，最后的修改日期就会有所不同，原始服务器就会回送新的文档。否则，服务器会注意到缓存的最后修改日期与服务器文档当前的最后修改日期相符，会返回一个304 Not Modified响应。</cached></p>
<h3 id="If-None-Match-实体标签再验证"><a href="#If-None-Match-实体标签再验证" class="headerlink" title="If-None-Match:实体标签再验证"></a>If-None-Match:实体标签再验证</h3><p>  有些情况下仅使用最后修改日期进行再验证是不够的。</p>
<ul>
<li><p>有些文档可能会被周期性地重写（比如，从一个后台进程中写入），但实际包含的数据常常是一样的。尽管内容没有变化，但修改日期会发生变化。</p>
</li>
<li><p>有些文档可能被修改了，但所做修改并不重要，不需要让世界范围内的缓存都重装数据（比如对拼写或注释的修改）</p>
</li>
<li>有些服务器无法准确地判定其页面的最后修改日期</li>
<li>有些服务器提供的文档会在亚秒间隙发生变化（比如，实时监视器），对这些服务器来说，以一秒为粒度的修改日期可能就不够用了。</li>
</ul>
<p>为了解决这些问题，HTTP允许用户对被称为实体标签（ETag）的“版本标识符”进行比较。实体标签是附加到文档上的任意标签（引用字符串）。它们可能包含了文档的序列号或版本名，或者是文档内容的校验和及其他指纹信息。</p>
<p>当发布者对文档进行修改时，可以修改文档的实体标签来说明这个新的版本。这样，如果实体标签被修改了，缓存就可以用If-None-Match条件首部来GET文档的新副本了。<br>比如：缓存中有一个实体标签为v2.6的文档。它会与原始服务器进行再验证，如果标签v2.6不再匹配，就会请求一个新对象。标签仍然与之匹配，会返回一条304 Not Modified响应。<br>如果服务器上的实体标签已经发生了变化（可能变成了v3.0）。服务器会在一个200 OK响应中返回新的内容以及相应的新ETag</p>
<p>缓存分强弱缓存<br>ETag可以用前缀”W/“来标识弱验证器。</p>
<p>原始服务器一定不能为两个不同的实体重用一个特定的强实体标签值，或者为两个语义不同的实体重用一个特定的弱实体标签值。缓存条目都可能会留存任意长的时间，与国企时间无关，有人可能希望当缓存验证条目时，绝对不会再次使用在过去某一时刻获得的验证器，这种愿望可能不太现实。</p>
<p>什么时候应该使用实体标签和最近修改日期</p>
<p>如果服务器回送了一个实体标签，HTTP/1.1客户端就必须使用实体标签验证器。如果服务器只回送了一个Last-Modified值，客户端就可以使用If-Modified-Since验证。如果实体标签和最后修改日期都提供了，客户端就应该使用这两种再验证方案，这样HTTP/1.0和HTTP/1.1缓存就都可以正确响应了。</p>
<p>除非HTTP/1.1原始服务器无法生成实体标签验证器，否则就应该发送一个出去，如果使用弱实体标签有优势的话，发送的可能就是个弱实体标签，而不是强实体标签。而且，最好同时发送一个最近修改值。</p>
<p>如果HTTP/1.1缓存或服务器收到的请求既带有If-Modified-Since，又带有实体标签条件首部，那么只有这两个条件都满足时，才能返回304 Not Modified响应。</p>
<h2 id="控制缓存的能力"><a href="#控制缓存的能力" class="headerlink" title="控制缓存的能力"></a>控制缓存的能力</h2><p>服务器可以通过HTTP定义的几种方式来指定在文档过期之前可以将其缓存多长时间，按照优先级递减的顺序，服务器可以：<br>附加一个Cache-Control:no-store首部到响应中去<br>附加一个Cache-Contorl:no-cache首部到响应中去<br>must-revalidate<br>max-age<br>Expires日期<br>不附加过期信息，让缓存确定自己的过期日期</p>
<h3 id="no-Store与no-Cache响应首部"><a href="#no-Store与no-Cache响应首部" class="headerlink" title="no-Store与no-Cache响应首部"></a>no-Store与no-Cache响应首部</h3><p>HTTP/1.1提供了几种限制对象缓存，或者限制提供已缓存对象的方式，以维持对象的新鲜度。no-store首部和no-cache首部可以防止缓存提供未经证实的已缓存对象；</p>
<p>Pragma: no-cache<br>Cache-Control: no-store<br>Cache-Control: no-cache</p>
<p>标识为no-store的响应会禁止缓存对响应进行复制。缓存通常会像非缓存代理服务器一样，向客户端转发一条no-store响应，然后删除对象。</p>
<p>标识为no-cache的响应实际上是可以存储在本地缓存区中的。只是在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。这个首部使用do-not-serve-from-cache-without-revalidation这个名字更恰当一些。</p>
<p>HTTP/1.1提供Pragma: no-cache首部是为了兼容HTTP/1.0+。除了与只理解Pragma: no-cache的HTTP/1.0应用程序交互时，HTTP 1.1应用程序都应该使用Cache-Control: no-cache.</p>
<h3 id="max-age响应首部"><a href="#max-age响应首部" class="headerlink" title="max-age响应首部"></a>max-age响应首部</h3><p>Cache-Control: max-age首部表示的是从服务器将文档传来之时起，可以认为此文档处于新鲜状态的秒数。还有一个s-maxage首部（注意maxage的中间没有连接线），其行为与max-age类似，但仅适用于共享（公有）缓存；</p>
<p>Cache-Control: max-age=3600<br>Cache-Control:s-maxage=3600</p>
<p>服务器可以请求缓存不要缓存文档，或者将最大使用期设置为0，从而在每次访问的时候进行刷新：<br>Cache-Control: max-age=0<br>Cache-Control:s-maxage=0</p>
<h3 id="Expires响应首部"><a href="#Expires响应首部" class="headerlink" title="Expires响应首部"></a>Expires响应首部</h3><p>不推荐使用Expires首部，它指定的是实际的过期日期而不是描述。HTTP设计者后来认为，由于很多服务器的时钟都不同步，或者不正确，所以最好还是用剩余秒数，而不是绝对时间来表示过期时间。可以通过计算过期值和日期值之间的秒数差来计算类似的新鲜生存期：<br>Expires: Fri, 05 Jul 2002, 05:00:00 GMT<br>有些服务器还会回送一个Expires:0响应首部，试图将文档置于永远过期的状态，但这种语法是非法的，可能给某些软件带来问题。应该试着支持这种结构的输入，但不应该产生这种结构的输出。</p>
<h3 id="must-revalidate响应首部"><a href="#must-revalidate响应首部" class="headerlink" title="must-revalidate响应首部"></a>must-revalidate响应首部</h3><p>可以配置缓存，使其提供一些陈旧（过期）的对象，以提供性能。如果原始服务器希望缓存严格遵守过期信息，可以在原始响应中附加一个Cache-Control:must-revalidation首部</p>
<p>Cache-Control: must-revalidate</p>
<p>Cache-Control: must-revalidate响应首部告诉缓存，在事先没有跟原服务器进行再验证的情况下，不能提供这个对象的陈旧副本。缓存仍然可以随意提供新鲜的副本。如果在缓存进行must-revalidate新鲜度检查时，原始服务器不可用，缓存就必须返回一条504 Gateway Timeout错误。</p>
<p>注意事项</p>
<p>文档过期系统并不是一个完美的系统。如果发布者不小心分配了一个很久之后地 过期日期，在文档过期之前，她要对文档做的任何修改都不一定能显示在所有缓存中。因此，很多发布者都不会使用很长的过期时间，而且，很多发布者甚至都不使用过期日期，这样缓存就很难确定文档会在多长时间内保持新鲜了。</p>
<p><strong>内容来源：</strong>《HTTP权威指南》</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/08/理解Resource-Timing/" itemprop="url">
                  理解Resource Timing
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-01-08T21:38:59+08:00" content="2017-01-08">
              2017-01-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/性能优化/" itemprop="url" rel="index">
                    <span itemprop="name">性能优化</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/01/08/理解Resource-Timing/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/08/理解Resource-Timing/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>理解资源在网络上被收集的各个阶段是很重要的。这个是解决加载问题的基础。</p>
<ul>
<li><p>理解资源请求时间的阶段</p>
</li>
<li><p>了解每个阶段提供了什么样的Resouce Timing API</p>
</li>
<li><p>在timeline图表中理解不同的性能问题的指标，比如一系列透明的bars或者打的绿色的块。</p>
</li>
</ul>
<p>所有的网络请求被认为是资源。因为它们是通过网络被获取的，这些资源在resouce timing那里有不同的生命周期表示。Network Panel界面使用对开发者来说，使用相同的可用的Resouce Timing API</p>
<p>注意： 当使用Resouce Timing API处理跨域资源的时候，确保所有资源有CORS的header头。</p>
<p>对于每一个独立的被接收的资源，Resouce Timing API 提供了一套丰富的API细节。这个请求的主要的生命周期阶段如下：</p>
<ol>
<li>重定向</li>
<li>立即开始startTime</li>
<li>如果重定向发生了，redirectStart就开始了</li>
<li>如果重定向结束，redirectEnd就发生了</li>
<li>App Cache</li>
<li>如果application cache满足了请求，fetchStart就会发生</li>
<li>DNS</li>
<li>在DNS请求的开始，domainLookupStart触发</li>
<li>在DNS请求结束时，domainLookupEnd触发</li>
<li>TCP</li>
<li>当初始化连接到服务器时，connectStart触发</li>
<li>如果TLS或者SSL被用了，当安全握手开始的时候，secureConnectionStart触发</li>
<li>当服务器连接完成时，connectEnd触发</li>
<li>Request</li>
<li>请求的资源一旦被发送到服务器，requestStart触发</li>
<li>Response</li>
<li>当服务器初始化响应请求的时候，responseStart触发</li>
<li>当请求结束并且数据被接收到时，responseEnd触发</li>
</ol>
<h3 id="DevTools中查看"><a href="#DevTools中查看" class="headerlink" title="DevTools中查看"></a>DevTools中查看</h3><p>以下代码可以运行在console里查看<br>performance.getEntriesByType(‘resource’).filter(item =&gt; item.name.includes(“style.css”))</p>
<img src="/2017/01/08/理解Resource-Timing/resource.png" alt="Resource Timing" title="Resource Timing">
<h4 id="Queuing（队列）"><a href="#Queuing（队列）" class="headerlink" title="Queuing（队列）"></a>Queuing（队列）</h4><p>在队列中的请求意味着：<br>    这个请求被渲染引擎推迟了，因为它被考虑优先级低于一些关键资源（scripts/styles）.这个经常出现在images上面<br>    请求会被搁置，直到等到一个不可用的TCP socket连接被释放。<br>    因为浏览器在HTTP1协议上对于每个源来说，仅仅允许连接6个TCP，所以请求会被搁置<br>    时间被花在建立磁盘缓存上了（通常来说非常快）</p>
<h4 id="Stalled-Blocking"><a href="#Stalled-Blocking" class="headerlink" title="Stalled/Blocking"></a>Stalled/Blocking</h4><p>在请求被发送前的等待时间。这个时间是等待任何描述Queuing的原因的时间。另外，这个时间包含花费在代理协商的任何时间。</p>
<h4 id="Proxy-Negotiation"><a href="#Proxy-Negotiation" class="headerlink" title="Proxy Negotiation"></a>Proxy Negotiation</h4><p>和一个代理服务连接的协商时间</p>
<h4 id="DNS-Lookup"><a href="#DNS-Lookup" class="headerlink" title="DNS Lookup"></a>DNS Lookup</h4><p>DNS寻址时间。在一个页面中每一个新的域名需要完成一个完整的路由寻址。</p>
<h4 id="Initial-Connection-Connecting"><a href="#Initial-Connection-Connecting" class="headerlink" title="Initial Connection/Connecting"></a>Initial Connection/Connecting</h4><p>建立连接的时间，包含TCP握手/重试和协商SSL的时间</p>
<h4 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h4><p>完成一次SSL握手的时间</p>
<h4 id="Request-Sent-Sending"><a href="#Request-Sent-Sending" class="headerlink" title="Request Sent/Sending"></a>Request Sent/Sending</h4><p>网络请求时间。通常来说，是零点几毫秒。</p>
<h4 id="Waiting-TTFB"><a href="#Waiting-TTFB" class="headerlink" title="Waiting(TTFB)"></a>Waiting(TTFB)</h4><p>等待初始化响应的时间，也可以认为是第一个字节的时间。这个时间捕捉了到服务器的往返时间，除此之外还有等待服务器的发送响应的时间。</p>
<h4 id="Content-Download-Downloading"><a href="#Content-Download-Downloading" class="headerlink" title="Content Download/Downloading"></a>Content Download/Downloading</h4><p>接收响应数据所花的时间</p>
<h3 id="诊断网络问题"><a href="#诊断网络问题" class="headerlink" title="诊断网络问题"></a>诊断网络问题</h3><p>通过Network Panel可以查看到很多明显的可能存在的问题。找到这些问题需要对客户端和服务器如何交互，对协议上的限制有个很好的理解。</p>
<h4 id="Queued-or-Stalled-系列"><a href="#Queued-or-Stalled-系列" class="headerlink" title="Queued or Stalled 系列"></a>Queued or Stalled 系列</h4><p>最普遍的问题是一系列被排队和阻塞的请求。这意味着太多资源从单一域名下请求了。在HTTP 1.0/1.1 连接下，Chrome强制执行每一个Host有6个TCP连接的最大值。假如你一次请求了12个资源，先6个资源开始，剩下的6个进入队列。一旦开始的那6个中有一个被请求完了，在队列中的第一个将开始请求进程。</p>
<p>为了解决HTTP1 中的这个问题，你可以实现domain的拆分。在你的应用上可以建立多个子域名来提供给资源服务。然后在子域名中，均匀地分割资源然后提供服务。</p>
<p>对于HTTP1连接的修复不能应用在HTTP2的连接上。事实上，这样会影响它。如果以部署了HTTP2，不要使用域名拆分你的资源，因为这样会和HTTP2的设计使用上冲突。在HTTP2中，有一个单独的TCP连接到服务器提供一个多路复用连接。这个就会摆脱HTTP1中的6个连接的限制，并且多个资源能够在单独的连接中同时被传输。</p>
<h4 id="获取第一个字节时间太慢"><a href="#获取第一个字节时间太慢" class="headerlink" title="获取第一个字节时间太慢"></a>获取第一个字节时间太慢</h4><p>一个慢的TTFB被认为是一个很长的等待时间。建议这个时间在200ms以下。一个高的TTFB时间可能暴露两个主要问题中的一个</p>
<ol>
<li>在客户端和服务器端有很差的网络情况</li>
<li>服务器应用响应很慢</li>
</ol>
<p>为了描述一个高TTFB，首先尽可能切掉网络，理想情况下，从本地访问应用，看是否有大的TTFB。如果有，那么应用需要优化响应速度。这可能需要优化数据库查询，实现某些部分内容的缓存存储，或者修改你的服务器配置。在后端有太多原因让访问变慢。在你的软件上做些研究，发现什么部分不能满足你的性能预期。</p>
<p>如果本地访问TTFB比较低，那么在你客户端和服务器之间的网络可能就是这个问题。网络可能被各种事情阻塞。在客户端和服务器端之间有很多点，并且每一个点都有自己的连接限制，并且都可能导致问题出现。测试问题的最简单的方法是减去它从你的应用到另一个主机，并且看TTFB是否提升。</p>
<h4 id="高吞吐能力"><a href="#高吞吐能力" class="headerlink" title="高吞吐能力"></a>高吞吐能力</h4><p>如果你看到在Content Download阶段花费了大量时间，那么提升服务器响应或则连接它们在一起都没用。最主要的解决办法是发送较少的字节。</p>
<p><strong>原文链接:</strong> <a href="https://developers.google.com/web/tools/chrome-devtools/network-performance/understanding-resource-timing" target="_blank" rel="external">Understanding Resouce Timing</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/08/用RAIL模型来测量性能/" itemprop="url">
                  用RAIL模型来测量性能
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-01-08T16:31:26+08:00" content="2017-01-08">
              2017-01-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/性能优化/" itemprop="url" rel="index">
                    <span itemprop="name">性能优化</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/01/08/用RAIL模型来测量性能/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/08/用RAIL模型来测量性能/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>RAIL是一个以用户为中心的性能模型。每个web app在它自己的生命周期中都有这四个独立的方面，性能以不同的方式来表现它们</p>
<img src="/2017/01/08/用RAIL模型来测量性能/rail.png" alt="RAIL" title="RAIL">
<ol>
<li><p>关注用户；最终目的不是在任何特定的设备上让你的网站表现的更快，最终是让你的用户感到快乐</p>
</li>
<li><p>立即响应给用户；在100ms以内感知用户输入</p>
</li>
<li><p>有动画或者滚动操作的时候，能够产生10ms以内一帧的效果</p>
</li>
<li><p>尽可能利用主线程的空闲时间</p>
</li>
<li><p>保持用户的参与；在1000ms以内分发互动内容</p>
</li>
</ol>
<h3 id="关注用户"><a href="#关注用户" class="headerlink" title="关注用户"></a>关注用户</h3><p>努力提升性能的目的是为了用户。用户花费在你网站的大部分时间不是等你加载，但是当使用的时候确实有等待响应。理解用户如何感知性能延迟</p>
<h4 id="Delay-amp-User-Reaction"><a href="#Delay-amp-User-Reaction" class="headerlink" title="Delay &amp; User Reaction"></a>Delay &amp; User Reaction</h4><p>0-16ms</p>
<p>人们异常地擅长追踪运动，如果动画不平滑了，他们是不喜欢的。用户感知动画渲染的平滑情况是尽可能每秒60帧。也就是说每帧16ms，包含浏览器绘制新的frame到屏幕上，离开一个app大约10ms，这个时间就能产生一个frame.</p>
<p>0-100ms<br>在这个时间窗口里响应一个用户的动作，用户会感觉结果是立即响应的。如果时间长了，在动作和反应之间的连接是断掉的。</p>
<p>100-300ms</p>
<p>可察觉得轻微的延迟</p>
<p>300-1000ms</p>
<p>在这个时间窗口里，延迟让人有这是要操作的任务的一部分的感觉。对于大多数用户来说，加载页面或者切换页面成为了一个任务。</p>
<p>1000ms以上</p>
<p>超过1秒，用户就会对于他们要执行的任务失去焦点</p>
<p>10秒以上<br>用户就会沮丧并且不喜欢的放弃这个任务；他们可能之后就不会再回来执行这个任务了</p>
<h3 id="Response-响应-：100ms内的响应"><a href="#Response-响应-：100ms内的响应" class="headerlink" title="Response(响应)：100ms内的响应"></a>Response(响应)：100ms内的响应</h3><p>在用户注意到延迟之前，你有100ms的时间来响应用户的输入。这个应用于大多数输入，比如点击按钮，切换form控件或者开始动画。这个不能应用于touch drags或者滚动操作。</p>
<p>如果你不响应，在操作和反应之间的连接就会断掉。用户就会注意到。</p>
<p>立即响应用户的操作是很明显的，但并不总是对的。在100ms的窗口内做其他更有价值的工作，但要注意不能阻碍用户。如果可能的话，在后台执行。</p>
<p>对于超过500ms的操作，总是提供反馈信息</p>
<h3 id="Animation-动画-：10ms生成一帧"><a href="#Animation-动画-：10ms生成一帧" class="headerlink" title="Animation(动画)：10ms生成一帧"></a>Animation(动画)：10ms生成一帧</h3><p>动画不仅仅是花俏的UI效果。比如，滚动和touch drags也是动画类型。</p>
<p>当动画帧率变化的时候，用户是注意到的。你的目标是做成60fps，并且每帧不得不完整的走过以下步骤：<br>JavaScript-&gt;Style-&gt;Layout-&gt;Paint-&gt;Composite</p>
<p>从数学角度来看，每一帧有大约16ms（1000ms/60 frames per second=16.66ms per frame）.但是，因为浏览器需要一些时间来在屏幕上绘制新的frame，你的代码需要在10ms内完成执行。</p>
<p>像动画这种高压点像，你根本无处可做，你都不能进行绝对的最小化处理。只要有可能，利用100ms的重计算工作的响应，能够让你最大可能的做成60fps</p>
<h3 id="Idle-最大化空闲时间"><a href="#Idle-最大化空闲时间" class="headerlink" title="Idle:最大化空闲时间"></a>Idle:最大化空闲时间</h3><p>利用空闲时间完成延迟工作。比如，保持预加载数据到最小值以至于你的app加载快速，并且使用空闲时间加载剩下的数据。</p>
<p>延迟工作应该分组到大约50ms的块中。如果用户开始交互，那么以最高优先级来响应它。</p>
<p>为了允许100ms以内的响应，app需要每50ms以内回到主线程，诸如执行它的像素管道，响应给用户输入等等</p>
<p>50ms块的内容执行的时候，仍然确认可以立即响应的时候，允许其完成任务</p>
<h3 id="Load-1000ms内发送内容"><a href="#Load-1000ms内发送内容" class="headerlink" title="Load: 1000ms内发送内容"></a>Load: 1000ms内发送内容</h3><p>如果你不能保证1秒内加载你的站点，用户的关注点就会游离，他们处理任务的感知就会断裂。</p>
<p>RAIL度量总结</p>
<p>通过RAIL矩阵评估你的站点，使用Chrome DevTools的Timeline来记录用户的操作。然后在Timeline里检查记录的times</p>
<p>RAIL Step                   Key Metric          User Action</p>
<p>Response     输入延迟小于100ms（从按到绘制）    用户按了一个按钮（比如，打开一个导航）</p>
<p>Animation  每一帧的工作完成在16ms以内 （从JS到绘制）     用户滚动页面，拖拽一个手指，或者看一个动画。当拖拽时，应用的响应主要是手指的位置，比如pulling to refresh，或者滑动一个轮播。这个度量仅仅应用于拖拽的持续过程，不包含开始</p>
<p>Idle   主线程js工作块不超过50ms   用户不和页面交互，但是主线程在用户的下一个输入之前有足够可用的时间</p>
<p>Load  在1秒内页面准备好可用  用户加载页面并看到主要的内容</p>
<p><strong>原文链接：</strong><a href="https://developers.google.com/web/fundamentals/performance/rail" target="_blank" rel="external">RAIL性能测量</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/08/如何进行性能优化/" itemprop="url">
                  如何进行性能优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-01-08T15:45:57+08:00" content="2017-01-08">
              2017-01-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/性能优化/" itemprop="url" rel="index">
                    <span itemprop="name">性能优化</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/01/08/如何进行性能优化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/08/如何进行性能优化/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们为什么要做性能优化，终极原因是我们的网站被访问的慢了，担心用户流失。</p>
<p>那我们如何做性能优化呢，需要做各个环节去查找原因。我在这里列举一些可能存在问题的地方：</p>
<ol>
<li>网络原因</li>
<li>文件大小</li>
<li>页面渲染问题</li>
<li>前端、后端缓存问题</li>
<li>脚本执行原因</li>
<li>接口问题</li>
<li>磁盘问题</li>
<li>服务端程序问题</li>
<li>数据库问题</li>
</ol>
<p>我们一般会从前端到后端来追踪性能瓶颈</p>
<p>下面我们简单分析一下从浏览器请求到服务器响应的环节</p>
<ol>
<li>首屏加载的全过程</li>
<li>TCP连接简述</li>
<li>Web服务器会做些什么</li>
</ol>
<p>navigationStart-&gt;redirectStart-&gt;redirectEnd-&gt;fetchStart-&gt;domainLookupStart-&gt;domainLookupEnd-&gt;connectStart-&gt;secureConnectStart-&gt;connectEnd-&gt;requestStart-&gt;responseStart-&gt;responseEnd-&gt;domLoading-&gt;domInteractive-&gt;domContentLoaded-&gt;domCompleted-&gt;loadEventStart-&gt;loadEventEnd</p>
<img src="/2017/01/08/如何进行性能优化/firstPaint.png" alt="首屏渲染全过程" title="首屏渲染全过程">
<p>接着我们来看一下HTTP/HTTPS请求的过程：</p>
<p>世界上几乎所有的HTTP通信都是由TCP/IP承载的，TCP/IP是全球计算机及网络设备都在使用的一种常用的分组交换网络分层协议集。客户端应用程序可以打开一条TCP/IP连接，连接到可能运行在世界任何地方的服务器应用程序。一旦连接建立起来了，在客户端和服务器的计算机之间交换的报文就永远不会丢失、受损或者失序。</p>
<p>HTTP请求：</p>
<p>比如，你想获取Joe的五金商店最新的电动工具价目表：<br><a href="http://www.joes-hardware.com:80/power-tools.html" target="_blank" rel="external">http://www.joes-hardware.com:80/power-tools.html</a></p>
<p>1.浏览器收到这个URL是，会解析出主机名，www.joes-hardware.com<br>2.浏览器查询这个主机名的IP地址（DNS） 202.43.78.3</p>
<ol>
<li>浏览器获得端口号(80)</li>
<li>浏览器发起到202.43.78.3端口80的连接<br>5.浏览器向服务器发送一条HTTP GET报文</li>
<li>浏览器从服务器读取HTTP响应报文</li>
<li>浏览器关闭连接</li>
</ol>
<p>HTTPS请求：</p>
<p>SSL是个二进制协议，与HTTP完全不同，其流量是承载在另一个端口上的（443）。<br>需要进行安全握手操作，SSL安全参数握手过程如下：</p>
<ol>
<li>客户端发送可供选择的密码并请求证书，服务器发送选中的密码和证书</li>
<li>客户端发送保密信息，客户端和服务器生成密钥</li>
<li>客户端和服务器互相告知，开始加密过程</li>
</ol>
<p>最后在服务器端，简单来说，会执行以下几项任务：</p>
<p>1.建立连接——接受一个客户端连接，或者如果不希望与这个客户端建立连接，就将其关闭<br>2.接收请求——从网络中读取一条HTTP请求报文<br>3.处理请求——对请求报文进行解释，并采取行动<br>4.访问资源——访问报文中指定的资源<br>5.构建响应——创建带有正确首部的HTTP响应报文<br>6.发送响应——将响应回送给客户端<br>7.记录事务处理过程——将与已完成事务有关的内容记录在一个日志文件中</p>
<p>总体来说，从浏览器请求-&gt;网络连接-&gt;中间件-&gt;服务器，从前到后，从后到前的环节进行分析</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/01/2016总结/" itemprop="url">
                  2016总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-01-01T10:12:02+08:00" content="2017-01-01">
              2017-01-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/mind/" itemprop="url" rel="index">
                    <span itemprop="name">mind</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/01/01/2016总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/01/2016总结/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2016总结写太多就太矫情了，就把工作和生活的经历写一下，2017年稳扎稳打，不要有太多的想法，专精于几件事情就够了</p>
<h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><ul>
<li>结婚  </li>
<li>跳槽  </li>
<li>买房  </li>
<li>车祸 </li>
<li>旅游 </li>
<li>过户 </li>
<li>装修 </li>
<li>验收</li>
</ul>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><ul>
<li>lithe模块加载器combo改造</li>
<li>lithe的localStorage模块缓存</li>
<li>tag平台的gitlab版本</li>
<li>前端性能监控平台</li>
<li>MV*框架GMP</li>
<li>RN/Weex调研</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/29/Nginx缓存配置向导/" itemprop="url">
                  Nginx缓存配置向导
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-29T16:43:45+08:00" content="2016-12-29">
              2016-12-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/nginx/" itemprop="url" rel="index">
                    <span itemprop="name">nginx</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/29/Nginx缓存配置向导/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/29/Nginx缓存配置向导/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们都知道应用程序和网站的性能是其成功的最关键因素。但是，在使你的应用程序和网站性能更好的过程中并不总是很清晰。代码质量和基础架构当然很关键，但是在很多情况下，通过关注在一些基础应用分发技术上，你能够很大程度上提升你的应用的终端用户体验。其中一个例子是在你的应用栈中实施和优化缓存。这篇文章会包含一些技术能帮助初学者和高级用户进行性能优化，通过在nginx中使用web cache features。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>web cache存在于客户端和源服务器(origin server)之间，保存它所有使用的内容的副本。如果一个客户端请求的内容被缓存已经保存过了，那么客户端就会直接返回文件内容，不去请求源服务器了。这个可以来提升网站性能，因为web cache更接近客户端，这样会更高效的使用应用服务器，因为不用每次请求都去服务器生成页面。</p>
<p>在浏览器和应用服务器之间，有很多潜在的caches:客户端浏览器缓存，中间件缓存，内容分发网络(CDN)，还有负载均衡或者反向代理在应用服务器前面。即便是在反向代理或者负载均衡的层级，缓存也能极大的提升性能。</p>
<p>讲一个例子，去年我接受了一个加载慢的网站性能调优的任务。我注意的第一件事是网站花了一秒钟才打开首页。在一些debug后，我发现原因是页面被标记为不可缓存，每一次请求都会动态生成一次。页面本身不经常改变并且没有被定制化，所以这种情况是没有必要的。作为实验，我通过使用负载均衡标记主页可缓存5秒，结果是显而易见的提升。第一个字节的时间下降到了很小的微秒，并且页面加载明显加载快了。</p>
<p>在一个应用的技术栈里面，nginx作为反向代理或者负载均衡是最普遍的。nginx有一系列很全的缓存特性。下一节我们来讨论如何使用nginx来配置基本的缓存。</p>
<h2 id="如何设置和配置基本缓存"><a href="#如何设置和配置基本缓存" class="headerlink" title="如何设置和配置基本缓存"></a>如何设置和配置基本缓存</h2><p>仅需要两个指令就可开启基本缓存：proxy_cache_path和proxy_cache。<br>proxy_cache_path 设置缓存的路径和配置<br>proxy_cache 激活缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">proxy_cache_path /path/to/cache levels=1:2 keys_zone=my_cache:10m max_size=10g</div><div class="line">                 inactive=60m use_temp_path=off;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">...</div><div class="line">    location / &#123;</div><div class="line">        proxy_cache my_cache;</div><div class="line">        proxy_pass http://my_upstream;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>proxy_cache_path指令的定义设置如下：</p>
<ul>
<li>/path/to/cache/ 缓存的本地路径</li>
<li>levels 设置在/path/to/cache/目录下的一个两层目录。在单独的目录下大量的文件会使访问变慢，所以我们建议对于大部分缓存部署来说使用两层目录结构。如果levels没有指定，nginx会把所有文件放在同一个文件夹下。</li>
<li>keys_zone 设置一个共享缓存区来存储缓存的keys和metadata，诸如使用定时器等。在内存中有这些keys的一个copy能使nginx快速的确定是否一个请求时HIT还是MISS，不用再去磁盘读了，更加加速了检查。一个1MB的区域能够存储大于8000个key，所以例子里10m的配置能存储大约8万个key.</li>
<li>max_size 设置缓存的最大值（例子里是10GB）。这个是可选的；如果不设置一个值，允许缓存增长到可使用的磁盘空间。当缓存大小达到限制，一个进程会调用缓存管理器移除那些最近最少使用的文件，目的是为了让缓存大小低于最大限制。</li>
<li>inactive 指定一个文件如果没有访问，它能够保留的时长。在这个例子中，一个文件如果在60分钟之内没有被访问过，就会通过缓存管理进程删除掉，无论它是否过期。默认值10分钟（10m）。不活跃的内容和过期的内容是不同的。nginx是不能自动删除那些被cache control header定义的过期内容的。(例子中：Cache-Control:max-age=120)。过期内容(stale)仅仅当它被标记为inactive会被删掉。当过期内容被访问了，nginx会从源服务器(origin server)重新请求刷新它，这样就重置了文件的inactive 时间器。</li>
<li>nginx首先会把缓存文件写到一个临时存储区域，并且use_temp_path=off 指令指明了Nginx把它们都写到同一个文件夹下。我们建议你设置参数为off避免在文件系统中有不必要的数据备份。use_temp_path从nginx version 1.7.10开始加入了。</li>
</ul>
<p>最后，proxy_cache指令意思是：那些匹配父级location URL的区块(例子中是 /)都是需要缓存的内容。你可以把proxy_cache指令放到到server区块；也可以应用到所有location的区块，应用到那些没有自己proxy_cache指令的服务器上。</p>
<h2 id="当源服务器挂了，分发缓存内容"><a href="#当源服务器挂了，分发缓存内容" class="headerlink" title="当源服务器挂了，分发缓存内容"></a>当源服务器挂了，分发缓存内容</h2><p>nginx 内容缓存的一个强大的特性是nginx可以配置成当它不能够从源服务器上获取新的内容的时候，可以从缓存中分发stale的内容。假如所有的源服务器都挂了或者临时很繁忙，刚说的情况就会发生。不能够传递错误给客户端，nginx会从缓存中分发它过期的文件版本。这是提供一个对nginx代理的服务器一个额外的错误容忍度，能够确保在服务失败或者负载高峰期时正常运行。为了确保这个功能，需要包含一个指令 proxy_cache_use_stale<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">    ...</div><div class="line">    proxy_cache_use_stale error timeout http_500 http_502 http_503 http_504;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个配置是说，如果nginx接收一个error,timeout或者从源服务器上任何5xx的错误，并且此请求有一个过期缓存版本，那么将分发这个过期版本，而不会把错误发给客户端</p>
<h2 id="调优缓存"><a href="#调优缓存" class="headerlink" title="调优缓存"></a>调优缓存</h2><p>nginx对于cache的性能调优有大量的选项。这里有个例子显示了其中一些：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">proxy_cache_path /path/to/cache levels=1:2 keys_zone=my_cache:10m max_size=10g</div><div class="line">                 inactive=60m use_temp_path=off;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    ...</div><div class="line">    location / &#123;</div><div class="line">        proxy_cache my_cache;</div><div class="line">        proxy_cache_revalidate on;</div><div class="line">        proxy_cache_min_uses 3;</div><div class="line">        proxy_cache_use_stale error timeout updating http_500 http_502 http_503</div><div class="line">                              http_504;</div><div class="line">        proxy_cache_lock on;</div><div class="line">        proxy_pass http://my_upstream;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>指令如下：</p>
<ul>
<li><p>proxy_cache_revalidate 此指令是让nginx使用有条件的GET的请求，当从源服务器请求内容刷新本地内容的时候。如果一个客户端请求一个被缓存的内容，但是cache control headers定义的expire已经过期了，如果GET请求的header头里面包含If-Modified-Since，nginx将这个请求发送到源服务器。这个节省带宽，因为当它header中记录的Last-Modified 被改变后，服务器会发送完整的内容，这时候nginx会缓存到它。</p>
</li>
<li><p>proxy_cache_min_uses 在Nginx缓存客户端请求的资源前该资源可请求的次数。这是很有用的，假如缓存持续的填满，这个能确保最频繁使用的项目被增加到缓存中。默认值为1.</p>
</li>
<li><p>proxy_cache_use_stale updating参数是说nginx会分发过期的内容，如果客户端请求一个资源，这时资源从源服务器上会更新下来，而不是向服务器重新请求。请求过期文件的第一个用户不得不等待它从源服务器上更新下来。直到更新的文件被完全下载下来，这个过期的文件会返回给所有后续的请求。</p>
</li>
<li><p>如果proxy_cache_lock 是可用的，如果多个客户端请求一个文件，这个文件又没有在缓存中，这些请求中的第一个请求被允许请求到源服务器。其他请求等这个请求回来，然后从缓存中获取这个文件。没有proxy_cache_lock选项不可用的话，所有的请求缓存都不会命中，并且直接请求到源服务器。</p>
</li>
</ul>
<h2 id="分隔缓存到多个硬盘中"><a href="#分隔缓存到多个硬盘中" class="headerlink" title="分隔缓存到多个硬盘中"></a>分隔缓存到多个硬盘中</h2><p>使用nginx,没有必要穿件一个RAID。如果有多个硬盘，nginx能够被使用分隔缓存到这些硬盘上来。下面有个例子，使用基于request URI在两个硬盘上来分隔客户端请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">proxy_cache_path /path/to/hdd1 levels=1:2 keys_zone=my_cache_hdd1:10m</div><div class="line">                 max_size=10g inactive=60m use_temp_path=off;</div><div class="line">proxy_cache_path /path/to/hdd2 levels=1:2 keys_zone=my_cache_hdd2:10m</div><div class="line">                 max_size=10g inactive=60m use_temp_path=off;</div><div class="line"></div><div class="line">split_clients $request_uri $my_cache &#123;</div><div class="line">              50%          “my_cache_hdd1”;</div><div class="line">              50%          “my_cache_hdd2”;</div><div class="line">&#125;</div><div class="line">server &#123;</div><div class="line">    ...</div><div class="line">    location / &#123;</div><div class="line">        proxy_cache $my_cache;</div><div class="line">        proxy_pass http://my_upstream;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两个proxy_cache_path 定义了两个缓存（my_cache_hdd1和my_cache_hdd2）在两个不同的磁盘路径上。split_clients 指定了50%的请求的缓存来自my_cache_hdd1里另一半来自my_cache_hdd2里。$request_uri 会指定哪一个缓存被用来给每一个请求，对一个给定的URI的请求的结果总是在相同的cache中被缓存。</p>
<p><a href="https://www.nginx.com/blog/nginx-caching-guide/" target="_blank" rel="external">原文链接</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/05/fiddler配置IOS设备/" itemprop="url">
                  fiddler配置IOS设备
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-05T21:53:04+08:00" content="2016-12-05">
              2016-12-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/tech/" itemprop="url" rel="index">
                    <span itemprop="name">tech</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/05/fiddler配置IOS设备/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/05/fiddler配置IOS设备/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://docs.telerik.com/fiddler/Configure-Fiddler/Tasks/ConfigureForiOS" target="_blank" rel="external">fiddler官方文档</a></p>
<p><a href="http://www.telerik.com/blogs/using-fiddler-with-apple-ios-devices" target="_blank" rel="external">blog</a></p>
<p>下载认证：<a href="http://www.telerik.com/docs/default-source/fiddler/addons/fiddlercertmaker.exe?sfvrsn=2" target="_blank" rel="external">CertMaker for iOS and Android</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="zeromike" />
          <p class="site-author-name" itemprop="name">zeromike</p>
          <p class="site-description motion-element" itemprop="description">这是zeromike的时光机器,技术博客</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">21</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zhangzhaoaaa" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/coolzeromike" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.weibo.com/youthwhite" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/zeromike" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-zhihu"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zeromike</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"lovecoder"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

  


</body>
</html>
